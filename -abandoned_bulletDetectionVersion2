# +-----------------------------------------+
# +------------ ABANDON REASON -------------+
# +-----------------------------------------+
# The new bullet detection system is made
# for improve performace purpose. But then
# abandoned due to bullet piercing detection
# make performce worse than before.
# +-----------------------------------------+
# +-----------------------------------------+
# +-----------------------------------------+



# +-----------------------------------------+
# +------------ DETEECT METHOD -------------+
# +-----------------------------------------+
# 1. Get the distance between shooter and all
#    entities.
# 2. Predict bullet's location using distance
#    to entities(Step 1).
# 3. Detect if the predict location is in
#    the entity's custom hitbox. If the
#    predict location is inside the hitbox,
#    that means the entity get hit.
# 4. Caculate bullet final damage with
#    factors such as bullet fly distance and
#    headshot.
# +-----------------------------------------+
# +-----------------------------------------+
# +-----------------------------------------+

function guns_shoot(shooter: player, gunStats: numbers):
	set {_loopTimes} to ceil({_gunStats::8} / 150)
	set {_delay} to ("%(0.4 / {_loopTimes})% seconds" parsed as time span)
	loop {_loopTimes} times:
		loop {_gunStats::5} times:
			set {_loopShootLocation} to guns_applyAccuracy(({_shooter}'s head), {_gunStats::7})
			guns_registerShot({_shooter}, {_loopShootLocation}, {_gunStats::*})
		wait {_delay}

function guns_registerShot(shooter: player, shootLocation: location, gunStats: numbers):
	loop all entities:
		if loop-entity is not a player or zombie:
			set {_invalidEntity} to true
		if loop-entity is {_shooter}:
			set {_invalidEntity} to true
		if {_invalidEntity} is not set:
			set {_entityLocation} to location 1 meter above loop-entity
			set {_distance} to distance between {_shootLocation} and {_entityLocation}
			set {_bulletLocation} to guns_bulletLocation({_shootLocation}, {_distance})
#			drawDot particle "fireworkspark", center {_bulletLocation}, visibleRange 100
			set {_detectLocation} to location 0.4 meter behind {_bulletLocation}
			set {_detectResult} to false
			loop 3 times:
				set {_detectLocation} to location 0.2 meter infront of {_detectLocation}
				set {_detection} to guns_confirmHit((loop-entity's location), {_detectLocation}, 0.1)
				if {_detection} is true:
					set {_detectResult} to true
					exit 1 loop
			if {_detectResult} is true:
				set {_dataRange} to round({_distance} * 100)
				set {_hittedEntities::%{_dataRange}%} to loop-entity
		delete {_invalidEntity}
	set {_piercing} to {_gunStats::4}
	set {_range} to {_gunStats::2}
	loop {_hittedEntities::*}:
		set {_hitRange} to ((loop-index parsed as number) / 100)
		if {_hitRange} > {_gunStats::2}:
			exit 1 loop
		loop all blocks between block at {_shootLocation} and block at {_detectLocation}:
			if loop-block is not air or water or sapling or sign or torch or vine or ladder or barrier:
				add loop-block to {_hittedBlock::*}
		if ((amount of {_hittedBlock::*}) * 2) >= {_piercing}:
			set {_range} to floor(distance between {_shootLocation} and {_hittedBlock::1})
			exit 1 loop
		send "DAMAGE -> %{_hittedEntities::%loop-index%}%" to all players
		remove 1 from {_piercing}
		if {_piercing} <= 0:
			exit 1 loop
	if (amount of {_hittedEntities::*}) = 0:
		loop all blocks between block at {_shootLocation} and block at {_detectLocation}:
			if loop-block is not air or water or sapling or sign or torch or vine or ladder or barrier:
				remove 1 from {_piercing}
				if {_piercing} <= 0:
					set {_range} to floor(distance between {_shootLocation} and loop-block)
					exit 1 loop
	guns_bulletPath({_shootLocation}, {_range})

function guns_bulletDamageCaculation(gunBaseDamage: number, hitDistance: number, bulletRange: number) :: number:
	set {_rangePercentage} to ({_hitDistance} / {_bulletRange})
	if {_rangePercentage} <= 0.5:
		return {_gunBaseDamage}
	else:
		return ({_gunBaseDamage} - ({_gunBaseDamage} * ({_rangePercentage} - 0.5) / 2))

function guns_bulletLocation(startLocation: location, bulletFlyDistance: number) :: location:
	set {_finalLocation} to location {_bulletFlyDistance} meter infront of {_startLocation}
#	set {_meterInfront} to location 1 meter infront of {_startLocation}
#	set {_xChange} to (({_meterInfront}'s x coords) - ({_startLocation}'s x coords))
#	set {_yChange} to (({_meterInfront}'s y coords) - ({_startLocation}'s y coords))
#	set {_zChange} to (({_meterInfront}'s z coords) - ({_startLocation}'s z coords))
#	set {_finalLocation} to {_startLocation}
#	set {_finalLocation}'s x coords to (({_startLocation}'s x coords) + ({_xChange} * {_bulletFlyDistance}))
#	set {_finalLocation}'s y coords to (({_startLocation}'s y coords) + ({_yChange} * {_bulletFlyDistance}))
#	set {_finalLocation}'s z coords to (({_startLocation}'s z coords) + ({_zChange} * {_bulletFlyDistance}))
	return {_finalLocation}
